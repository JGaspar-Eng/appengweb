// src/app/lajes/biapoiada/page.tsx
"use client";

import { useMemo, useState, useEffect } from "react";
import InternalHeader from "@/app/components/InternalHeader";
import Footer from "@/app/components/Footer";
import {
  TRELICAS,
  CONCRETOS,
  ACOS,
  TABELA_K,
  DIAMETROS_PADRAO,
  TABELA_ACO,
  findClosestIdxByKc,
} from "@/components/constantes"; // <- caminho correto

type KeyOf<T> = Extract<keyof T, string>;
const AREA_TRELICA_CM2 = 0.40;

function num(v: number, d = 3) {
  return Number.isFinite(v) ? v.toFixed(d) : "–";
}

// colunas fixas conforme sua TABELA_K
function getBetaXFromRow(row: number[], concretoKey: KeyOf<typeof CONCRETOS>): number {
  const col: Record<KeyOf<typeof CONCRETOS>, number> =
    { C20: 1, C25: 2, C30: 3, C35: 4, C40: 5, C45: 6, C50: 7 };
  return row[col[concretoKey]];
}
function getKsFromRow(row: number[], acoKey: KeyOf<typeof ACOS>): number | null {
  const col: Record<KeyOf<typeof ACOS>, number> = { CA25: 8, CA50: 9, CA60: 10 };
  const v = row[col[acoKey]];
  return (v ?? null) as number | null;
}

function sugerirBitolas(areaNec: number) {
  const ops: { desc: string; area: number; sobra: number }[] = [];
  for (const diam of DIAMETROS_PADRAO) {
    const areas = TABELA_ACO[diam];
    areas.forEach((a, i) => {
      if (a >= areaNec) ops.push({ desc: `${i + 1}Ø${diam}`, area: a, sobra: a - areaNec });
    });
  }
  return ops.sort((a, b) => a.sobra - b.sobra).slice(0, 3);
}

/** Esboço simples da laje: mostra Lx e Ly e destaca o menor vão */
function SlabSketch({ Lx, Ly, menor }: { Lx: number; Ly: number; menor: "Lx" | "Ly" | null }) {
  // mantém proporção visual
  const max = Math.max(Lx || 1, Ly || 1);
  const w = 220 * (Lx / max || 1);
  const h = 220 * (Ly / max || 1);
  return (
    <svg width="260" height="220" viewBox="0 0 260 220" aria-hidden="true">
      <g transform={`translate(${(260 - w) / 2}, ${(220 - h) / 2})`}>
        <rect
          x="0" y="0" width={w} height={h} rx="10"
          fill="none"
          className={menor ? "stroke-[var(--color-accent)]" : ""}
          strokeWidth={3}
          stroke="currentColor"
        />
        {/* Lx (horizontal) */}
        <line x1="0" y1={h + 8} x2={w} y2={h + 8} stroke="currentColor" />
        <text x={w / 2} y={h + 22} textAnchor="middle" fontSize="12">
          Lx = {Number.isFinite(Lx) ? num(Lx, 2) : "–"} m {menor === "Lx" ? "(menor)" : ""}
        </text>
        {/* Ly (vertical) */}
        <line x1={w + 8} y1="0" x2={w + 8} y2={h} stroke="currentColor" />
        <text x={w + 14} y={h / 2} fontSize="12" writingMode="tb" glyphOrientationVertical="auto">
          Ly = {Number.isFinite(Ly) ? num(Ly, 2) : "–"} m {menor === "Ly" ? "(menor)" : ""}
        </text>
      </g>
    </svg>
  );
}

export default function LajeBiapoiadaPage() {
  // escolhas padrão
  const [trelicaKey, setTrelicaKey] = useState<KeyOf<typeof TRELICAS>>("TR12");
  const [concretoKey, setConcretoKey] = useState<KeyOf<typeof CONCRETOS>>("C30");
  const [acoKey, setAcoKey] = useState<KeyOf<typeof ACOS>>("CA50");

  // entrada principal
  const [q, setQ] = useState<number>(5);        // kN/m²
  const [L, setL] = useState<number>(3.85);     // m (preenchido/autualizado pelo Lx/Ly)

  // lados da laje (para escolher automaticamente o menor vão)
  const [Lx, setLx] = useState<number>(5.30);
  const [Ly, setLy] = useState<number>(3.85);

  // escolha da linha K
  const [kIdxEscolhido, setKIdxEscolhido] = useState<number | null>(null);

  // sempre que Lx/Ly mudarem, definir L = menor(Lx, Ly)
  useEffect(() => {
    if (!isFinite(Lx) || !isFinite(Ly)) return;
    const menor = Math.min(Lx, Ly);
    setL(menor);
  }, [Lx, Ly]);

  const menorVao: "Lx" | "Ly" | null = !isFinite(Lx) || !isFinite(Ly)
    ? null
    : (Lx <= Ly ? "Lx" : "Ly");

  // dados derivados
  const tre = TRELICAS[trelicaKey];
  const conc = CONCRETOS[concretoKey];
  const aco = ACOS[acoKey];

  const bf_m = tre.bf / 100;
  const qLinha = q * bf_m;               // kN/m
  const Vk = (qLinha * L) / 2;           // kN
  const Mk_kNm = (qLinha * L * L) / 8;   // kN·m
  const Md_kNcm = Mk_kNm * 1.4 * 100;    // kN·cm

  // método do professor (Kc)
  const Kc = (tre.bw * tre.d * tre.d) / Md_kNcm;

  // sugestão de linha
  const kIdxSugerido = useMemo(() => findClosestIdxByKc(Kc), [Kc]);
  const linha = kIdxEscolhido != null ? TABELA_K[kIdxEscolhido] : null;

  const betaX = linha ? getBetaXFromRow(linha, concretoKey) : undefined;
  const ks = linha ? getKsFromRow(linha, acoKey) : undefined;

  const x = betaX != null ? betaX * tre.d : undefined;     // cm
  const ehT = x != null ? x > 1.25 * tre.hf : undefined;

  const As = ks != null ? (ks * Md_kNcm) / tre.d : undefined;             // cm²
  const AsAdotar = As != null ? Math.max(As - AREA_TRELICA_CM2, 0) : undefined;
  const sugestoes = AsAdotar != null ? sugerirBitolas(AsAdotar) : [];

  return (
    <main className="min-h-screen flex flex-col bg-[var(--color-bg)] text-[var(--color-text)]">
      <InternalHeader title="Laje Biapoiada" showBackButton backHref="/calculadoras" />

      <div className="container mx-auto px-4 py-6 max-w-6xl">
        {/* Lx × Ly e inputs de carga/vão */}
        <section className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
          <div className="card p-4">
            <h2 className="font-bold mb-3">Geometria da laje (Lx × Ly)</h2>
            <div className="grid grid-cols-2 gap-3">
              <div>
                <label className="block text-sm mb-1">Lx (m)</label>
                <input
                  type="number" step={0.01}
                  className="w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
                  value={Lx} onChange={(e) => setLx(parseFloat(e.target.value))}
                />
              </div>
              <div>
                <label className="block text-sm mb-1">Ly (m)</label>
                <input
                  type="number" step={0.01}
                  className="w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
                  value={Ly} onChange={(e) => setLy(parseFloat(e.target.value))}
                />
              </div>
            </div>
            <div className="mt-3">
              <SlabSketch Lx={Lx} Ly={Ly} menor={menorVao} />
            </div>
            <div className="mt-2 text-sm">
              Menor vão adotado: <b>{num(L, 2)} m</b> ({menorVao ?? "—"})
            </div>
          </div>

          <div className="card p-4">
            <h2 className="font-bold mb-3">Carregamento</h2>
            <label className="block text-sm mb-1">q (kN/m²)</label>
            <input
              type="number" step={0.1}
              className="w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
              value={q} onChange={(e) => setQ(parseFloat(e.target.value))}
            />
            <div className="text-sm opacity-80 mt-2">
              Largura tributária bf = <b>{num(bf_m, 2)} m</b> → q' = <b>{num(qLinha, 3)} kN/m</b>
            </div>
          </div>

          <div className="card p-4">
            <h2 className="font-bold mb-3">Vão adotado</h2>
            <label className="block text-sm mb-1">L (m)</label>
            <input
              type="number" step={0.01}
              className="w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
              value={L} onChange={(e) => setL(parseFloat(e.target.value))}
            />
            <div className="text-sm opacity-80 mt-2">
              Você pode sobrescrever o menor vão manualmente se precisar.
            </div>
          </div>
        </section>

        {/* Materiais / treliça */}
        <section className="grid grid-cols-1 md:grid-cols-5 gap-4 mb-6">
          <div className="md:col-span-2">
            <label className="block mb-1 font-semibold">Treliça</label>
            <select
              className="w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
              value={trelicaKey}
              onChange={(e) => { setTrelicaKey(e.target.value as any); setKIdxEscolhido(null); }}
            >
              {Object.keys(TRELICAS).map(k => <option key={k} value={k}>{k}</option>)}
            </select>
            <div className="mt-2 text-sm opacity-80 grid grid-cols-2 gap-x-4">
              <div>bw: <b>{tre.bw} cm</b></div><div>bf: <b>{tre.bf} cm</b></div>
              <div>h: <b>{tre.h} cm</b></div><div>hf: <b>{tre.hf} cm</b></div>
              <div>d: <b>{tre.d} cm</b></div>
            </div>
          </div>

          <div>
            <label className="block mb-1 font-semibold">Concreto</label>
            <select
              className="w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
              value={concretoKey}
              onChange={(e) => { setConcretoKey(e.target.value as any); setKIdxEscolhido(null); }}
            >
              {Object.keys(CONCRETOS).map(k => <option key={k} value={k}>{k}</option>)}
            </select>
            <div className="mt-2 text-sm opacity-80">fcd: <b>{num(conc.fcd,3)}</b> kN/cm²</div>
          </div>

          <div>
            <label className="block mb-1 font-semibold">Aço</label>
            <select
              className="w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
              value={acoKey}
              onChange={(e) => { setAcoKey(e.target.value as any); setKIdxEscolhido(null); }}
            >
              {Object.keys(ACOS).map(k => <option key={k} value={k}>{k}</option>)}
            </select>
            <div className="mt-2 text-sm opacity-80">fyd: <b>{num(aco.fyd,3)}</b> kN/cm²</div>
          </div>

          <div className="card p-4">
            <div className="text-sm opacity-70">Esforços (ELU)</div>
            <div>Vk = <b>{num(Vk,3)}</b> kN</div>
            <div>Mk = <b>{num(Mk_kNm,3)}</b> kN·m</div>
            <div>Md = <b>{num(Md_kNcm,1)}</b> kN·cm</div>
            <div className="mt-2">Kc = <b>{num(Kc,3)}</b></div>
          </div>
        </section>

        {/* Tabela K clicável (enxuta + highlight amarelo/CIANO) */}
<section className="mb-8">
  <div className="flex items-center justify-between mb-2">
    <h2 className="text-lg font-bold">Tabela K — clique na linha a adotar</h2>
    <div className="text-sm">
      Sugerida:{" "}
      <span className="px-2 py-0.5 rounded-full bg-yellow-200 text-yellow-900">
        linha {kIdxSugerido + 1}
      </span>{" "}
      (Kc ≈ {num(TABELA_K[kIdxSugerido][0], 3)})
    </div>
  </div>

  <div className="overflow-auto rounded-xl border">
    <table className="min-w-full text-sm">
      <thead className="bg-[var(--color-card)]">
        <tr>
          <th className="px-2 py-2 text-left">Kc</th>
          <th className="px-2 py-2 text-left">{concretoKey} (βx)</th>
          <th className="px-2 py-2 text-left">{acoKey} (ks)</th>
        </tr>
      </thead>
      <tbody>
        {TABELA_K.map((row, i) => {
          const isSug = i === kIdxSugerido;
          const isSel = i === kIdxEscolhido;

          // amarelo para sugerida; CIANO para selecionada; hover suave em ciano
          const baseHover = "hover:bg-cyan-50 dark:hover:bg-neutral-800";
          const suggCls = "bg-yellow-100 dark:bg-yellow-900/30";
          const selCls  = "bg-cyan-100 dark:bg-cyan-900/30";
          const rowCls  = isSel ? selCls : isSug ? suggCls : baseHover;

          const bx = getBetaXFromRow(row, concretoKey); // βx da coluna do concreto escolhido
          const ksCell = getKsFromRow(row, acoKey);     // ks da coluna do aço escolhido

          return (
            <tr
              key={i}
              onClick={() => setKIdxEscolhido(i)}
              className={`cursor-pointer ${rowCls}`}
              title={isSug ? "Linha sugerida pela proximidade do Kc" : ""}
            >
              <td className="px-2 py-1 border-t">{row[0]}</td>
              <td className="px-2 py-1 border-t">{bx}</td>
              <td className="px-2 py-1 border-t">{ksCell ?? "–"}</td>
            </tr>
          );
        })}
      </tbody>
    </table>
  </div>

  {!linha && (
    <p className="mt-2 text-sm opacity-80">
      ➜ Clique na linha <b>em amarelo</b> (sugerida) para preencher <b>βx</b> e <b>ks</b>.
    </p>
  )}
</section>


        {/* Resultado principal */}
        {linha && (
          <section className="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-10">
            <div className="card p-4">
              <div>βx = <b>{num(getBetaXFromRow(linha, concretoKey),3)}</b></div>
              <div>ks = <b>{ks != null ? num(ks,3) : "–"}</b></div>
              <div className="mt-2">x = βx·d = <b>{num(x!,3)}</b> cm</div>
              <div>Verif. T: x {ehT ? ">" : "≤"} 1,25·hf → <b>{ehT ? "T verdadeira" : "retângulo eq."}</b></div>
            </div>

            <div className="card p-4">
              <div className="font-semibold mb-1">Armadura (método ks)</div>
              {ks == null ? (
                <div className="text-sm opacity-80">
                  Para esta linha não há <b>ks</b> para o aço selecionado.
                </div>
              ) : (
                <>
                  <div>As = ks·Md/d = <b>{num(As!,3)}</b> cm²</div>
                  <div>Desconto treliça (0,40): <b>{AREA_TRELICA_CM2.toFixed(2)}</b> cm²</div>
                  <div>As (adotar) = <b>{num(AsAdotar!,3)}</b> cm²</div>
                </>
              )}
            </div>

            <div className="card p-4">
              <div className="text-sm opacity-80">Sugestões de arranjo</div>
              <div className="mt-2 text-sm">
                {sugestoes.length
                  ? sugestoes.map((s, i) => (
                      <div key={i} className="mb-1">
                        {s.desc} — área {num(s.area,2)} cm² (sobra {num(s.sobra,2)} cm²)
                      </div>
                    ))
                  : "—"}
              </div>
              <div className="text-xs opacity-70 mt-2">
                *Método adotado: <b>As = ks·(Md/d)</b> e <b>As' = As − 0,40</b> cm² (mín. 0).
              </div>
            </div>
          </section>
        )}
      </div>

      <Footer />
    </main>
  );
}
