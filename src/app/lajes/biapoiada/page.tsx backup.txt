// src/app/lajes/biapoiada/page.tsx
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import InternalHeader from "@/app/components/InternalHeader";
import Footer from "@/app/components/Footer";
import RebarSketch from "@/components/SlabSketch"; // <-- seu desenho do arranjo (proporcional)
import {
  TRELICAS,
  CONCRETOS,
  ACOS,
  TABELA_K,
  DIAMETROS_PADRAO,
  TABELA_ACO,
} from "@/components/constantes";

type KeyOf<T> = Extract<keyof T, string>;
const AREA_TRELIÇA_CM2 = 0.40;

function num(v: number, d = 3) {
  return Number.isFinite(v) ? (v as number).toFixed(d) : "–";
}

/** --- PlanSketch: esboço simples Lx×Ly (somente para visual da geometria) --- */
function PlanSketch({ Lx, Ly, menor }: { Lx: number; Ly: number; menor: "Lx" | "Ly" | null }) {
  const max = Math.max(Lx || 1, Ly || 1);
  const w = 220 * (Lx / max || 1);
  const h = 220 * (Ly / max || 1);
  return (
    <svg width="260" height="220" viewBox="0 0 260 220" aria-hidden="true">
      <g transform={`translate(${(260 - w) / 2}, ${(220 - h) / 2})`}>
        <rect
          x="0" y="0" width={w} height={h} rx="10"
          fill="none"
          className={menor ? "stroke-[var(--color-accent)]" : ""}
          strokeWidth={3}
          stroke="currentColor"
        />
        <line x1="0" y1={h + 8} x2={w} y2={h + 8} stroke="currentColor" />
        <text x={w / 2} y={h + 22} textAnchor="middle" fontSize="12">
          Lx = {Number.isFinite(Lx) ? num(Lx, 2) : "–"} m {menor === "Lx" ? "(menor)" : ""}
        </text>
        <line x1={w + 8} y1="0" x2={w + 8} y2={h} stroke="currentColor" />
        <text x={w + 14} y={h / 2} fontSize="12" writingMode="tb">
          Ly = {Number.isFinite(Ly) ? num(Ly, 2) : "–"} m {menor === "Ly" ? "(menor)" : ""}
        </text>
      </g>
    </svg>
  );
}

/** Mapeamento fixo das colunas na TABELA_K (mantida como no arquivo constantes) */
const COL_CONCRETO: Record<KeyOf<typeof CONCRETOS>, number> =
  { C20: 1, C25: 2, C30: 3, C35: 4, C40: 5, C45: 6, C50: 7 };
const COL_ACO: Record<KeyOf<typeof ACOS>, number> =
  { CA25: 8, CA50: 9, CA60: 10 };

const getBxFromRow = (row: number[]) => row[0];
const getKcFromRow = (row: number[], c: KeyOf<typeof CONCRETOS>) => row[COL_CONCRETO[c]] ?? null;
const getKsFromRow = (row: number[], a: KeyOf<typeof ACOS>) =>
  (row[COL_ACO[a]] ?? null) as number | null;

function sugerirBitolas(areaNec: number) {
  const ops: { n: number; diam: number; desc: string; area: number; sobra: number }[] = [];
  for (const diam of DIAMETROS_PADRAO) {
    const areas = TABELA_ACO[diam];
    areas.forEach((a, i) => {
      const n = i + 1;
      if (a >= areaNec) ops.push({ n, diam, desc: `${n}Ø${diam}`, area: a, sobra: a - areaNec });
    });
  }
  return ops.sort((a, b) => a.sobra - b.sobra).slice(0, 6);
}

export default function LajeBiapoiadaPage() {
  // escolhas padrão
  const [trelicaKey, setTrelicaKey] = useState<KeyOf<typeof TRELICAS>>("TR12");
  const [concretoKey, setConcretoKey] = useState<KeyOf<typeof CONCRETOS>>("C30");
  const [acoKey, setAcoKey] = useState<KeyOf<typeof ACOS>>("CA50");

  // entrada principal
  const [q, setQ] = useState<number>(5);        // kN/m²
  const [L, setL] = useState<number>(3.85);     // m

  // lados da laje (menor vão automático)
  const [Lx, setLx] = useState<number>(5.30);
  const [Ly, setLy] = useState<number>(3.85);

  // Tabela K
  const [kIdxEscolhido, setKIdxEscolhido] = useState<number | null>(null);

  // Arranjo selecionado
  const [selN, setSelN] = useState<number | null>(null);
  const [selDiam, setSelDiam] = useState<number | null>(null);

  // Parâmetros de detalhamento
  const [pos, setPos] = useState<"inside" | "top">("inside");
  const [cobertura, setCobertura] = useState<number>(2.5); // cm
  const [sMin, setSMin] = useState<number>(1.5);           // cm
  const [sMax, setSMax] = useState<number>(20);            // cm

  // Refs para PDF
  const arranjoRef = useRef<HTMLDivElement>(null);
  const carimboRef = useRef<HTMLDivElement>(null);

  // Menor vão
  useEffect(() => {
    if (isFinite(Lx) && isFinite(Ly)) setL(Math.min(Lx, Ly));
  }, [Lx, Ly]);

  const menorVao: "Lx" | "Ly" | null =
    !isFinite(Lx) || !isFinite(Ly) ? null : (Lx <= Ly ? "Lx" : "Ly");

  // Dados
  const tre = TRELICAS[trelicaKey];
  const conc = CONCRETOS[concretoKey];
  const aco = ACOS[acoKey];

  const bf_m = tre.bf / 100;
  const qLinha = q * bf_m;                 // kN/m
  const Vk = (qLinha * L) / 2;             // kN
  const Mk_kNm = (qLinha * L * L) / 8;     // kN·m
  const Md_kNcm = Mk_kNm * 1.4 * 100;      // kN·cm

  // Kc = (bw * d^2) / Md
  const Kc = (tre.bw * tre.d * tre.d) / Md_kNcm;

  // Linha sugerida
  const kIdxSugerido = useMemo(() => {
    let idx = -1, best = Infinity;
    for (let i = 0; i < TABELA_K.length; i++) {
      const kc = getKcFromRow(TABELA_K[i], concretoKey);
      if (kc == null) continue;
      const diff = Math.abs(kc - Kc);
      if (diff < best) { best = diff; idx = i; }
    }
    return idx;
  }, [Kc, concretoKey]);

  const linha = kIdxEscolhido != null ? TABELA_K[kIdxEscolhido] : null;
  const Bx = linha ? getBxFromRow(linha) : undefined; // x/d
  const ks = linha ? getKsFromRow(linha, acoKey) : undefined;
  const x = Bx != null ? Bx * tre.d : undefined;      // cm
  const ehT = x != null ? x > 1.25 * tre.hf : undefined;

  // Método ks
  const As = ks != null ? (ks * Md_kNcm) / tre.d : undefined;
  const AsAdotar = As != null ? Math.max(As - AREA_TRELIÇA_CM2, 0) : undefined;
  const sugestoes = AsAdotar != null ? sugerirBitolas(AsAdotar) : [];

  const selecionarArranjo = (n: number, diam: number) => {
    setSelN(n);
    setSelDiam(diam);
  };

  // Verificações e espaçamento calculado
  const verif = useMemo(() => {
    if (!selN || !selDiam) return null;
    const n = selN;
    const phi = selDiam / 10; // cm
    const LARG = pos === "inside" ? tre.bw : tre.bf;
    const c = cobertura;
    const util = LARG - 2 * c;

    if (util <= 0) return { n, phi, LARG, c, sClear: 0, cabe: false, okMin: false, okMax: false };

    if (n === 1) {
      const cabe = phi <= util + 1e-9;
      return { n, phi, LARG, c, sClear: util - phi, cabe, okMin: true, okMax: true };
    }

    const sClear = (util - n * phi) / (n - 1);
    const cabe = sClear >= -1e-9;
    const okMin = sClear >= sMin - 1e-9;
    const okMax = sClear <= sMax + 1e-9;
    return { n, phi, LARG, c, sClear, cabe, okMin, okMax };
  }, [selN, selDiam, tre.bw, tre.bf, cobertura, sMin, sMax, pos]);

  // Exportar PDF (carimbo + arranjo)
  const handleExportPDF = async () => {
    if (!arranjoRef.current) return;
    const [html2canvas, jsPDF] = await Promise.all([
      import("html2canvas"),
      import("jspdf"),
    ]);
    const pdf = new jsPDF.jsPDF({ orientation: "p", unit: "pt", format: "a4" });
    const pageW = pdf.internal.pageSize.getWidth();

    if (carimboRef.current) {
      const c1 = await html2canvas.default(carimboRef.current, { scale: 2 });
      const img1 = c1.toDataURL("image/png");
      const w1 = pageW - 80, h1 = (c1.height / c1.width) * w1;
      pdf.addImage(img1, "PNG", 40, 40, w1, h1);
      const y = 40 + h1 + 20;
      const c2 = await html2canvas.default(arranjoRef.current, { scale: 2 });
      const img2 = c2.toDataURL("image/png");
      const w2 = pageW - 80, h2 = (c2.height / c2.width) * w2;
      pdf.addImage(img2, "PNG", 40, y, w2, h2);
    }
    pdf.save("laje_biapoiada.pdf");
  };

  return (
    <main className="min-h-screen flex flex-col bg-[var(--color-bg)] text-[var(--color-text)]">
      <InternalHeader title="Laje Biapoiada" showBackButton backHref="/calculadoras" />

      <div className="container mx-auto px-4 py-6 max-w-6xl">
        {/* Geometria / Carga / Vão */}
        <section className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
          <div className="card p-4">
            <h2 className="font-bold mb-3">Geometria da laje (Lx × Ly)</h2>
            <div className="grid grid-cols-2 gap-3">
              <label className="text-sm">Lx (m)
                <input type="number" step={0.01}
                  className="mt-1 w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
                  value={Lx} onChange={(e) => setLx(parseFloat(e.target.value))}/>
              </label>
              <label className="text-sm">Ly (m)
                <input type="number" step={0.01}
                  className="mt-1 w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
                  value={Ly} onChange={(e) => setLy(parseFloat(e.target.value))}/>
              </label>
            </div>
            <div className="mt-3 flex justify-center">
              <PlanSketch Lx={Lx} Ly={Ly} menor={(!isFinite(Lx)||!isFinite(Ly))?null:(Lx<=Ly?"Lx":"Ly")} />
            </div>
            <div className="mt-2 text-sm">
              Menor vão adotado: <b>{num(L,2)} m</b> ({menorVao ?? "—"})
            </div>
          </div>

          <div className="card p-4">
            <h2 className="font-bold mb-3">Carregamento</h2>
            <label className="block text-sm mb-1">q (kN/m²)</label>
            <input type="number" step={0.1}
              className="w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
              value={q} onChange={(e) => setQ(parseFloat(e.target.value))}/>
            <div className="text-sm opacity-80 mt-2">
              Largura tributária bf = <b>{num(tre.bf/100,2)} m</b> → q' = <b>{num(qLinha,3)} kN/m</b>
            </div>
          </div>

          <div className="card p-4">
            <h2 className="font-bold mb-3">Vão adotado</h2>
            <label className="block text-sm mb-1">L (m)</label>
            <input type="number" step={0.01}
              className="w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
              value={L} onChange={(e) => setL(parseFloat(e.target.value))}/>
            <div className="text-sm opacity-80 mt-2">
              Você pode sobrescrever o menor vão manualmente se precisar.
            </div>
          </div>
        </section>

        {/* Materiais / Treliça / Esforços */}
        <section className="grid grid-cols-1 md:grid-cols-5 gap-4 mb-6">
          <div className="md:col-span-2">
            <label className="block mb-1 font-semibold">Treliça</label>
            <select
              className="w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
              value={trelicaKey}
              onChange={(e) => { setTrelicaKey(e.target.value as any); setKIdxEscolhido(null); }}
            >
              {Object.keys(TRELICAS).map(k => <option key={k} value={k}>{k}</option>)}
            </select>
            <div className="mt-2 text-sm opacity-80 grid grid-cols-2 gap-x-4">
              <div>bw: <b>{tre.bw} cm</b></div><div>bf: <b>{tre.bf} cm</b></div>
              <div>h: <b>{tre.h} cm</b></div><div>hf: <b>{tre.hf} cm</b></div>
              <div>d: <b>{tre.d} cm</b></div>
            </div>
          </div>

          <div>
            <label className="block mb-1 font-semibold">Concreto</label>
            <select
              className="w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
              value={concretoKey}
              onChange={(e) => { setConcretoKey(e.target.value as any); setKIdxEscolhido(null); }}
            >
              {Object.keys(CONCRETOS).map(k => <option key={k} value={k}>{k}</option>)}
            </select>
            <div className="mt-2 text-sm opacity-80">fcd: <b>{num(conc.fcd,3)}</b> kN/cm²</div>
          </div>

          <div>
            <label className="block mb-1 font-semibold">Aço</label>
            <select
              className="w-full border rounded-lg px-3 py-2 bg-[var(--color-card)]"
              value={acoKey}
              onChange={(e) => { setAcoKey(e.target.value as any); setKIdxEscolhido(null); }}
            >
              {Object.keys(ACOS).map(k => <option key={k} value={k}>{k}</option>)}
            </select>
            <div className="mt-2 text-sm opacity-80">fyd: <b>{num(aco.fyd,3)}</b> kN/cm²</div>
          </div>

          <div className="card p-4">
            <div className="text-sm opacity-70">Esforços (ELU)</div>
            <div>Vk = <b>{num(Vk,3)}</b> kN</div>
            <div>Mk = <b>{num(Mk_kNm,3)}</b> kN·m</div>
            <div>Md = <b>{num(Md_kNcm,1)}</b> kN·cm</div>
            <div className="mt-2">Kc = <b>{num(Kc,3)}</b></div>
          </div>
        </section>

        {/* Tabela K (Bx | Cxx(kc) | CAxx(ks)) */}
        <section className="mb-8">
          <div className="flex items-center justify-between mb-2">
            <h2 className="text-lg font-bold">Tabela K — clique na linha a adotar</h2>
            <div className="text-sm">
              Sugerida:{" "}
              <span className="px-2 py-0.5 rounded-full bg-yellow-200 text-yellow-900">
                {kIdxSugerido >= 0 ? `linha ${kIdxSugerido + 1}` : "—"}
              </span>{" "}
              (Kc ≈ {num(Kc, 3)})
            </div>
          </div>

          <div className="overflow-auto rounded-xl border">
            <table className="min-w-full text-sm">
              <thead className="bg-[var(--color-card)]">
                <tr>
                  <th className="px-2 py-2 text-left">Bx</th>
                  <th className="px-2 py-2 text-left">{concretoKey} (kc)</th>
                  <th className="px-2 py-2 text-left">{acoKey} (ks)</th>
                </tr>
              </thead>
              <tbody>
                {TABELA_K.map((row, i) => {
                  const isSug = i === kIdxSugerido;
                  const isSel = i === kIdxEscolhido;

                  const baseHover = "hover:bg-cyan-50 dark:hover:bg-neutral-800";
                  const suggCls = "bg-yellow-100 dark:bg-yellow-900/30";
                  const selCls  = "bg-cyan-100 dark:bg-cyan-900/30";
                  const rowCls  = isSel ? selCls : isSug ? suggCls : baseHover;

                  const bxCell = getBxFromRow(row);
                  const kcCell = getKcFromRow(row, concretoKey);
                  const ksCell = getKsFromRow(row, acoKey);

                  return (
                    <tr key={i} onClick={() => setKIdxEscolhido(i)}
                        className={`cursor-pointer ${rowCls}`}
                        title={isSug ? "Linha sugerida pela proximidade do Kc" : ""}>
                      <td className="px-2 py-1 border-t">{bxCell}</td>
                      <td className="px-2 py-1 border-t">{kcCell ?? "–"}</td>
                      <td className="px-2 py-1 border-t">{ksCell ?? "–"}</td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>

          {!linha && (
            <p className="mt-2 text-sm opacity-80">
              ➜ Clique na linha <b>amarela</b> (sugerida) para preencher <b>Bx</b> e <b>ks</b>.
            </p>
          )}
        </section>

        {/* Resultados + Sugestões */}
        {linha && (
          <>
            <section className="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-6" ref={carimboRef}>
              <div className="card p-4">
                <div>Bx = <b>{num(Bx!,3)}</b></div>
                <div>ks = <b>{ks != null ? num(ks,3) : "–"}</b></div>
                <div className="mt-2">x = Bx·d = <b>{num((Bx ?? 0) * tre.d,3)}</b> cm</div>
                <div>Verif. T: x {ehT ? ">" : "≤"} 1,25·hf → <b>{ehT ? "T verdadeira" : "retângulo eq."}</b></div>
              </div>

              <div className="card p-4">
                <div className="font-semibold mb-1">Armadura (método ks)</div>
                {ks == null ? (
                  <div className="text-sm opacity-80">
                    Para esta linha não há <b>ks</b> para o aço selecionado.
                  </div>
                ) : (
                  <>
                    <div>As = ks·Md/d = <b>{num(As!,3)}</b> cm²</div>
                    <div>Desconto treliça (0,40): <b>{AREA_TRELIÇA_CM2.toFixed(2)}</b> cm²</div>
                    <div>As (adotar) = <b>{num(AsAdotar!,3)}</b> cm²</div>
                  </>
                )}
              </div>

              <div className="card p-4">
                <div className="text-sm opacity-80 mb-2">Sugestões (ordem econômica)</div>
                <div className="flex flex-col gap-2">
                  {sugestoes.map((s, i) => {
                    const selected = selN === s.n && selDiam === s.diam;
                    return (
                      <button
                        key={i}
                        onClick={() => selecionarArranjo(s.n, s.diam)}
                        className={`text-left px-3 py-2 rounded-lg border transition
                          ${selected ? "bg-cyan-100 dark:bg-cyan-900/30 border-cyan-300"
                                     : "hover:bg-cyan-50 dark:hover:bg-neutral-800"}`}
                        title={i === 0 ? "mais econômica" : undefined}
                      >
                        <div className="flex items-center justify-between">
                          <span className="font-semibold">{s.desc}</span>
                          <span className="text-xs opacity-70">{i === 0 ? "mais econômica" : ""}</span>
                        </div>
                        <div className="text-sm">
                          área {num(s.area,2)} cm² (sobra {num(s.sobra,2)} cm²)
                        </div>
                      </button>
                    );
                  })}
                </div>
              </div>
            </section>

            {/* Arranjo selecionado (desenho proporcional com réguas) */}
            {selN && selDiam && verif && (
              <section className="mb-10">
                <div className="card p-5" ref={arranjoRef}>
                  <div className="flex flex-col gap-3">
                    <div className="flex flex-wrap gap-3 items-end">
                      <label className="text-sm">
                        Posicionamento
                        <select
                          className="mt-1 ml-2 border rounded-lg px-3 py-2 bg-[var(--color-card)]"
                          value={pos}
                          onChange={(e) => setPos(e.target.value as any)}
                        >
                          <option value="inside">Dentro da nervura</option>
                          <option value="top">Sobre a mesa</option>
                        </select>
                      </label>
                      <label className="text-sm">
                        Cobertura c (cm)
                        <input
                          type="number" step={0.1}
                          className="mt-1 ml-2 w-24 border rounded-lg px-3 py-2 bg-[var(--color-card)]"
                          value={cobertura} onChange={(e) => setCobertura(parseFloat(e.target.value))}
                        />
                      </label>
                      <label className="text-sm">
                        s_min (cm)
                        <input
                          type="number" step={0.1}
                          className="mt-1 ml-2 w-24 border rounded-lg px-3 py-2 bg-[var(--color-card)]"
                          value={sMin} onChange={(e) => setSMin(parseFloat(e.target.value))}
                        />
                      </label>
                      <label className="text-sm">
                        s_max (cm)
                        <input
                          type="number" step={0.1}
                          className="mt-1 ml-2 w-24 border rounded-lg px-3 py-2 bg-[var(--color-card)]"
                          value={sMax} onChange={(e) => setSMax(parseFloat(e.target.value))}
                        />
                      </label>
                    </div>

                    <div className="mt-2 flex justify-center">
                      <RebarSketch
                        mode={pos}
                        widthCm={pos === "inside" ? tre.bw : tre.bf}
                        coverCm={cobertura}
                        n={verif.n}
                        diamMm={selDiam}
                        sClearCm={verif.n > 1 ? verif.sClear : null}
                        widthLabel={`${pos === "inside" ? "bw" : "bf"} = ${num(pos === "inside" ? tre.bw : tre.bf, 1)} cm`}
                      />
                    </div>

                    <div className="text-center text-sm mt-1">
                      {pos === "inside" ? (
                        <>bw = <b>{num(tre.bw,1)} cm</b> · Ø = <b>{num(selDiam/10,1)} cm</b> · n = <b>{selN}</b></>
                      ) : (
                        <>bf = <b>{num(tre.bf,1)} cm</b> · Ø = <b>{num(selDiam/10,1)} cm</b> · n = <b>{selN}</b></>
                      )}
                      <div className="mt-1">
                        {verif.n > 1 ? (
                          <>
                            s<sub>calc</sub> = <b>{num(Math.max(verif.sClear,0),2)}</b> cm · Cabe dentro da faixa útil ·{" "}
                            s<sub>min</sub> = {num(sMin,2)} cm {verif.okMin ? "✓" : "✗"} ·{" "}
                            s<sub>max</sub> = {num(sMax,2)} cm {verif.okMax ? "✓" : "✗"} ·{" "}
                            <b>{verif.cabe && verif.okMin && verif.okMax ? "OK geral" : "Ajustar"}</b>
                          </>
                        ) : (
                          <>
                            c = <b>{num(cobertura,2)} cm</b> · Cabe dentro da faixa útil · s<sub>max</sub> = {num(sMax,2)} cm ✓ · <b>OK geral</b>
                          </>
                        )}
                      </div>
                      <div className="opacity-70 text-xs mt-1">
                        *Informativo: s<sub>max(normativo)</sub> ≥ min(2·h, 20 cm) e 20,0 cm (ajustável acima).
                      </div>
                    </div>
                  </div>
                </div>

                <div className="mt-3 flex justify-center">
                  <button
                    onClick={handleExportPDF}
                    className="px-4 py-2 rounded-lg bg-[var(--color-accent)] text-white font-semibold shadow hover:bg-opacity-90 transition"
                  >
                    Exportar PDF (carimbo + arranjo)
                  </button>
                </div>
              </section>
            )}
          </>
        )}
      </div>

      <Footer />
    </main>
  );
}
